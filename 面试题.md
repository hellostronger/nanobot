# Nanobot 面试题

## 项目架构篇

### 1. 简述 Nanobot 项目的整体架构设计。

**答案**：Nanobot 采用基于消息总线的架构设计，核心组件包括：
- 用户输入通过 Channel（Telegram、WhatsApp）进入系统
- MessageBus 负责事件发布/订阅，实现组件间通信
- AgentLoop 是核心代理，处理消息、调用 LLM、执行工具
- 定时任务通过 CronService 和 HeartbeatService 驱动
- 支持多 LLM Provider（OpenRouter、Anthropic、OpenAI 等）

---

### 2. 什么是消息总线（MessageBus）模式？Nanobot 中是如何实现的？

**答案**：消息总线是一种发布-订阅模式，允许组件间松耦合通信。
Nanobot 中通过 `MessageBus` 类实现：
- `publish()` 方法发布事件到总线
- `subscribe()` 方法订阅感兴趣的事件
- 支持同步和异步事件处理
- 事件类型包括：入站消息、出站消息、内部事件等

---

### 3. AgentLoop 的主要职责是什么？

**答案**：AgentLoop 是核心处理循环，主要职责：
1. 接收和解析输入消息
2. 调用 LLM 生成响应
3. 执行工具调用
4. 管理对话状态和迭代
5. 返回最终结果给消息总线

---

### 4. Nanobot 支持哪些 LLM Provider？它们是如何实现的？

**答案**：支持的 Provider 包括：
- OpenRouter、Anthropic、OpenAI、Groq、Gemini、vLLM
- 通过 LiteLLM 库实现统一抽象
- 每个 Provider 在配置文件中配置 API Key 和端点
- 使用 OpenAI 兼容的 API 格式，便于扩展

---

### 5. 什么是 Subagent（子代理）？Nanobot 中如何实现？

**答案**：Subagent 是嵌套的代理实例，用于专门任务。通过 `spawn` 工具创建：
- 主代理可以调用 `spawn` 工具生成子代理
- 子代理有自己的指令和上下文
- 适用于复杂任务的分解和专业化处理
- 子代理结果会合并回主对话

---

## 核心组件篇

### 6. 解释 Nanobot 的工具（Tools）系统。

**答案**：工具系统：
- 工具是 `Tool` 基类的子类
- 注册到 AgentLoop 的 `_register_default_tools()` 方法
- 工具可以访问代理状态和上下文
- 执行后返回结果供 LLM 使用
- 支持动态加载和组合

---

### 7. Nanobot 如何处理异步操作？

**答案**：
- 使用 Python 原生 `asyncio`
- 所有 I/O 操作（网络、文件）均为异步
- `async/await` 关键字处理协程
- MessageBus 支持异步事件处理
- Channel 适配器也采用异步设计

---

### 8. 解释 Workspace 文件的作用。

**答案**：Workspace 位于 `~/.nanobot/workspace/`，包含：
- **AGENTS.md**：代理行为指令
- **SOUL.md**：代理人格和身份定义
- **USER.md**：用户信息和偏好
- **memory/MEMORY.md**：跨会话持久记忆
- 这些文件影响代理的响应方式和上下文

---

### 9. 什么是 Skills 系统？它与 Subagent 有什么关系？

**答案**：
- Skills 是预定义的子代理模板，位于 `nanobot/skills/`
- 每个 Skill 有 `SKILL.md` 描述其用途
- 通过 `spawn` 工具加载 Skills
- 允许复用专业化的代理配置
- Skill-Creator 是创建新技能的工具

---

### 10. HeartbeatService 是如何工作的？

**答案**：
- 每 30 分钟唤醒一次
- 检查 `HEARTBEAT.md` 文件
- 根据文件内容提示代理执行任务
- 用于定期维护、提醒或主动工作
- 保持代理活跃状态

---

## 配置与部署篇

### 11. Nanobot 的配置文件结构是怎样的？

**答案**：配置文件 `~/.nanobot/config.json` 包含：
- `providers.*.apiKey`：各 Provider 的 API 密钥
- `agents.defaults.model`：默认模型配置
- `channels.*`：Telegram/WhatsApp 设置
- `tools.web.search.api_key`：Web 搜索工具的 API 密钥

---

### 12. 如何添加一个新的 Tool？

**答案**：
1. 创建类继承 `Tool` 基类
2. 实现 required 方法
3. 在 `AgentLoop._register_default_tools()` 中注册
4. Tool 可以访问代理状态和执行上下文

---

### 13. 如何添加一个新的 LLM Provider？

**答案**：
1. 确保 Provider 兼容 OpenAI API 格式
2. 在配置文件中添加 Provider 配置
3. LiteLLM 会自动识别并支持
4. 需要时可扩展 Provider 封装类

---

### 14. Channel 适配器的职责是什么？

**答案**：
- 处理特定平台的协议（Telegram Bot API、WhatsApp HTTP API）
- 接收用户消息并转换为统一格式
- 将代理响应发送回对应平台
- 处理认证和连接管理
- 支持多平台并行运行

---

### 15. Nanobot 的会话（Session）管理是如何实现的？

**答案**：
- 位于 `nanobot/session/` 目录
- 维护对话历史和状态
- 支持对话上下文记忆
- 与消息总线集成
- 可以在运行时查询和修改会话

---

## 消息处理篇

### 16. 描述消息从用户到响应的完整流程。

**答案**：
1. 用户通过 Channel 发送消息
2. Channel 将消息发布到 MessageBus
3. AgentLoop 订阅并接收消息
4. AgentLoop 调用 LLM 生成响应
5. 如需要，执行 Tool 调用
6. 最终响应通过 MessageBus 发布
7. Channel 订阅响应并发送给用户

---

### 17. MessageBus 中有哪些主要事件类型？

**答案**：
- `InboundMessage`：用户发来的消息
- `OutboundMessage`：发送给用户的响应
- `InternalEvent`：内部触发的事件
- `ToolExecution`：工具执行事件
- 订阅者可以按需处理感兴趣的事件

---

### 18. Cron 任务是如何执行的？

**答案**：
1. 使用 `nanobot cron add` 命令添加任务
2. 任务存储在 `~/.nanobot/data/cron/jobs.json`
3. 系统按 cron 表达式调度
4. 触发时通过 AgentLoop 执行
5. 支持列表和删除操作

---

### 19. 什么是 LiteLLM？它在 Nanobot 中的作用是什么？

**答案**：
- LiteLLM 是一个统一的 LLM API 封装库
- 提供一致的接口调用不同 Provider
- 支持 OpenAI 格式的 API 调用
- Nanobot 使用它来简化多 Provider 切换
- 降低了切换 LLM 的复杂度

---

### 20. AgentLoop 如何处理多轮对话？

**答案**：
- 维护对话历史和上下文
- 每次迭代传入完整历史
- 支持设置最大迭代次数防止无限循环
- 工具执行结果合并到对话中
- 达到终止条件时返回最终响应

---

## 深入篇

### 21. Nanobot 的错误处理机制是怎样的？

**答案**：
- 工具执行错误会被捕获并返回给 LLM
- LLM 调用错误会触发重试或降级
- Channel 连接错误会尝试重连
- 使用 `rich` 库进行美化输出
- 支持配置错误回调

---

### 22. 如何扩展 Nanobot 支持新的聊天平台？

**答案**：
1. 在 `nanobot/channels/` 创建新适配器
2. 实现消息接收和发送接口
3. 处理平台特定的认证
4. 注册到消息总线
5. 在配置文件中配置通道参数

---

### 23. Nanobot 如何保证消息的顺序和一致性？

**答案**：
- 消息总线按顺序分发事件
- 每个 Channel 独立处理消息
- 使用异步处理提高并发能力
- 会话状态保证单对话上下文
- 通过事件 ID 去重和追踪

---

### 24. 解释 Tool 执行时的上下文传递机制。

**答案**：
- Tool 基类接收代理上下文
- 可以访问当前对话历史
- 可以修改代理状态
- 执行结果自动合并到响应
- 支持嵌套工具调用

---

### 25. Nanobot 的测试策略是什么？

**答案**：
- 使用 pytest 框架
- 单元测试覆盖核心组件
- 集成测试验证消息流
- Mock 外部依赖（LLM API）
- CI/CD 自动化测试

---

## CLI 篇

### 26. Nanobot 的 CLI 是用什么实现的？主要有哪些命令？

**答案**：
- 使用 **typer** 库构建 CLI
- 主要命令：
  - `agent`：运行代理（交互式或单次）
  - `gateway`：启动网关（Telegram/WhatsApp）
  - `status`：显示系统状态
  - `channels`：Channel 管理
  - `cron`：定时任务管理

---

### 27. 如何以交互模式运行 Nanobot 代理？

**答案**：使用命令：
```bash
nanobot agent
```
这会启动交互式对话，可以连续输入消息。

---

### 28. 如何发送单条消息并获取响应？

**答案**：使用命令：
```bash
nanobot agent -m "What is 2+2?"
```
适合脚本调用或快速测试。

---

### 29. 如何管理 WhatsApp 登录？

**答案**：
```bash
nanobot channels status    # 查看状态
nanobot channels login     # 显示 QR 码用于登录
```
WhatsApp 通过 QR 码认证。

---

### 30. 如何添加定时任务？

**答案**：使用命令：
```bash
nanobot cron add --name "daily" --message "Good morning!" --cron "0 9 * * *"
nanobot cron list          # 列出所有任务
nanobot cron remove <job_id>  # 删除任务
```
任务通过 cron 表达式调度。

---

## 高级功能篇

### 31. 什么是 Agent Defaults？它有什么作用？

**答案**：
- Agent Defaults 是代理的默认配置
- 位于配置文件 `agents.defaults` 部分
- 设置默认模型、超时时间等参数
- 可以被具体会话覆盖
- 提供统一的配置入口

---

### 32. Nanobot 如何处理长对话上下文？

**答案**：
- 对话历史存储在 Session 中
- 传入 LLM 时会压缩或截断
- 支持配置上下文长度限制
- 重要信息可写入 memory/MEMORY.md
- 平衡 token 消耗和上下文完整

---

### 33. 解释 Nanobot 中的 Event-driven 架构。

**答案**：
- 所有组件通过事件通信
- MessageBus 是事件中枢
- 发布-订阅模式解耦组件
- 支持同步和异步事件
- 易于扩展和集成新功能

---

### 34. 如何自定义代理的人格和身份？

**答案**：在 Workspace 文件中配置：
- **SOUL.md**：定义代理人格特征
- **AGENTS.md**：指定行为规则
- **USER.md**：记录用户偏好
- 这些文件在启动时加载并影响代理行为

---

### 35. Nanobot 的跨平台兼容性如何实现？

**答案**：
- 使用 Python 标准库减少依赖
- 抽象 Provider 接口适配不同 API
- Channel 适配器封装平台差异
- 配置文件屏蔽环境差异
- 支持 Windows、Linux、macOS

---

## 原理篇

### 36. MessageBus 的发布-订阅模式是如何实现的？

**答案**：
- 维护一个订阅者字典（事件类型 → 回调列表）
- `subscribe()` 将回调注册到对应事件
- `publish()` 遍历并调用所有订阅者
- 支持异步回调和优先级
- 可以动态添加/移除订阅

---

### 37. AgentLoop 中的迭代终止条件有哪些？

**答案**：
- 达到最大迭代次数
- LLM 返回停止标记
- 工具调用返回最终结果
- 出现错误或异常
- 用户主动中断

---

### 38. 解释 LiteLLM 的模型别名机制。

**答案**：
- LiteLLM 支持模型别名映射
- 如 `anthropic/claude-opus-4-5` 映射到实际端点
- 简化模型切换和配置
- 支持动态加载模型列表
- 统一费用统计

---

### 39. Tool 的返回值如何影响 LLM 的决策？

**答案**：
- 工具结果作为消息插入对话
- LLM 根据结果决定下一步行动
- 可以触发进一步的工具调用
- 或生成最终用户响应
- 结构化结果便于 LLM 解析

---

### 40. Nanobot 如何处理并发请求？

**答案**：
- 异步架构支持高并发
- 每个 Channel 独立处理
- 使用 asyncio 的事件循环
- 工具执行不阻塞其他请求
- 可配置并发限制

---

## 数据存储篇

### 41. Nanobot 使用什么方式存储数据？

**答案**：
- 配置文件：`~/.nanobot/config.json`
- 定时任务：`~/.nanobot/data/cron/jobs.json`
- Workspace 文件：`~/.nanobot/workspace/`
- 会话状态：内存或文件存储
- 纯文本/JSON 格式便于编辑

---

### 42. memory/MEMORY.md 有什么作用？如何管理？

**答案**：
- 长期记忆存储
- 跨会话保留重要信息
- 代理可以读取和写入
- 需要手动维护或自动摘要
- 帮助代理记住用户偏好

---

### 43. 会话数据是如何持久化的？

**答案**：
- 对话历史存储在 Session 对象
- 可配置持久化到文件
- 支持加载历史会话
- 按用户/时间组织
- 可以在配置中调整

---

## 开发篇

### 44. 如何为 Nanobot 开发新的 Skill？

**答案**：
1. 在 `nanobot/skills/` 创建目录
2. 编写 `SKILL.md` 描述用途
3. 定义子代理的行为指令
4. 添加工具或辅助文件
5. 通过 `spawn` 工具加载使用

---

### 45. Nanobot 的代码结构是怎样的？

**答案**：
```
nanobot/
├── agent/         # 核心代理逻辑
├── bus/           # 消息总线
├── providers/     # LLM Provider
├── agent/tools/   # 内置工具
├── channels/      # 聊天平台
├── cron/          # 定时任务
├── heartbeat/     # 心跳服务
├── session/       # 会话管理
└── skills/        # 技能模板
```

---

### 46. 开发模式下如何安装 Nanobot？

**答案**：
```bash
pip install -e .
```
以可编辑模式安装，修改代码后无需重新安装。

---

### 47. 如何调试 Nanobot 的消息流？

**答案**：
- 使用 `nanobot status` 查看系统状态
- 启用详细日志输出
- 订阅 MessageBus 事件查看传递
- 使用 Python 调试器
- 检查 Channel 和 Agent 的日志

---

### 48. Nanobot 依赖哪些主要第三方库？

**答案**：
- **typer**：CLI 构建
- **rich**：终端美化输出
- **asyncio**：异步支持
- **litellm**：LLM 统一接口
- **pyyaml/jq**：配置和 JSON 处理

---

## 实战篇

### 49. 如何配置 Nanobot 使用 OpenRouter？

**答案**：在 `~/.nanobot/config.json` 中：
```json
{
  "providers": {
    "openrouter": {
      "apiKey": "your-api-key"
    }
  },
  "agents": {
    "defaults": {
      "model": "openrouter/anthropic/claude-opus-4-5"
    }
  }
}
```

---

### 50. 如何为代理添加 Web 搜索能力？

**答案**：
1. 获取 Brave Search API Key
2. 在配置中添加工具配置：
```json
{
  "tools": {
    "web": {
      "search": {
        "api_key": "your-brave-key"
      }
    }
  }
}
```
3. 内置 web 工具会使用该配置

---

### 51. 如何限制代理的响应长度？

**答案**：
- 在 AgentLoop 配置 max_tokens
- LLM Provider 设置输出限制
- 可以自定义后处理截断
- Workspace 文件中也可以指导
- 综合考虑 token 消耗

---

### 52. 如何让代理在特定条件下触发动作？

**答案**：
- 使用 HeartbeatService 定期检查
- Cron 任务定时触发
- 工具调用中实现业务逻辑
- 监听特定 MessageBus 事件
- 编写自定义 Tool 实现

---

## 原理篇（续）

### 53. 解释异步生成器在 Nanobot 中的应用。

**答案**：
- 用于流式响应 LLM 输出
- `async for` 迭代生成的内容
- 实时显示部分结果
- 提高用户体验
- 减少首字符延迟

---

### 54. MessageBus 的事件优先级如何实现？

**答案**：
- 订阅时可以指定优先级
- 高优先级回调先执行
- 可以设置回调的执行顺序
- 重要事件优先处理
- 在事件对象中携带优先级

---

### 55. Tool 调用是如何与 LLM 交互的？

**答案**：
1. LLM 返回工具调用请求
2. AgentLoop 解析并执行工具
3. 工具结果格式化为消息
4. 结果插入对话历史
5. LLM 基于结果继续生成

---

### 56. Nanobot 如何防止无限循环？

**答案**：
- 设置最大迭代次数
- 工具调用计数限制
- 检测重复的对话模式
- LLM 的停止标记检测
- 用户可以随时中断

---

## 扩展篇

### 57. 如何自定义代理的响应格式？

**答案**：
- 在 AGENTS.md 中指定格式规则
- 使用工具输出结构化数据
- 后处理响应文本
- 自定义 Tool 返回特定格式
- 通过 System Prompt 控制

---

### 58. Nanobot 支持插件系统吗？

**答案**：
- 通过 Tool 系统扩展功能
- 可以动态加载自定义工具
- Skill 机制提供模板
- 目前没有官方插件市场
- 社区可以贡献 Skills 和 Tools

---

### 59. 如何集成自定义的 LLM 端点？

**答案**：
1. 确认端点兼容 OpenAI API
2. 在配置中添加 Provider
3. 使用对应的模型名称
4. LiteLLM 会自动处理请求
5. 可能需要配置额外参数

---

### 60. 如何为特定用户定制代理行为？

**答案**：
- 在 USER.md 中记录用户信息
- 使用不同的 Workspace 配置
- 在会话中设置用户上下文
- 通过 Tool 查询用户偏好
- 多账户配置支持

---

## 运维篇

### 61. 如何监控 Nanobot 的运行状态？

**答案**：
- 使用 `nanobot status` 查看概览
- 查看 Channel 连接状态
- 检查消息总线事件流
- 监控日志输出
- 设置告警机制

---

### 62. Nanobot 的日志系统是如何工作的？

**答案**：
- 使用 Python logging 模块
- 可配置日志级别
- 输出到控制台和文件
- 支持结构化日志
- 便于问题排查

---

### 63. 如何升级 Nanobot？

**答案**：
```bash
pip install -U nanobot
```
或从源码更新：
```bash
git pull && pip install -e .
```
注意检查配置文件兼容性。

---

### 64. 遇到 LLM API 错误如何处理？

**答案**：
- 检查 API Key 是否有效
- 确认网络连接正常
- 查看 Rate Limit 配额
- 尝试切换 Provider
- 检查模型名称是否正确

---

### 65. 如何备份和恢复 Nanobot 配置？

**答案**：
- 备份 `~/.nanobot/` 目录
- 包含 config.json、workspace 文件
- 数据文件在 `data/` 目录
- 可以使用版本控制
- 恢复时覆盖对应文件

---

## 进阶篇

### 66. 解释 Subagent 的上下文隔离机制。

**答案**：
- 每个 Subagent 有独立上下文
- 主代理决定传递哪些信息
- 可以设置 Subagent 的指令边界
- 结果合并时进行信息筛选
- 防止信息泄露和混乱

---

### 67. Nanobot 如何处理多语言内容？

**答案**：
- LLM 本身支持多语言
- 消息总线传递 Unicode
- 配置文件支持 UTF-8
- Workspace 可以是多语言指导
- 与具体 Provider 能力相关

---

### 68. 什么是 Agent Loop 的"思考预算"？

**答案**：
- 限制 LLM 的推理迭代次数
- 控制每次对话的复杂度
- 防止过度思考简单问题
- 在配置中设置参数
- 平衡质量和成本

---

### 69. 如何实现代理的"记忆"功能？

**答案**：
- 使用 memory/MEMORY.md 持久化
- 重要信息写入长期记忆
- 会话历史提供短期记忆
- 可以使用 Tool 读取/写入
- 设计记忆摘要机制

---

### 70. Nanobot 的安全性考虑有哪些？

**答案**：
- API Key 存储在本地配置
- 不向第三方发送敏感信息
- 可以设置 Tool 调用白名单
- 沙箱化工具执行
- 用户控制数据分享

---

## 比较篇

### 71. Nanobot 与其他 AI 代理框架相比有什么特点？

**答案**：
- 超轻量级（~4000 行代码）
- 易于理解和修改
- 专注于个人使用场景
- 多 Provider 多 Channel 支持
- 基于事件的灵活架构

---

### 72. 为什么选择 LiteLLM 而不是直接使用各 Provider SDK？

**答案**：
- 统一接口减少适配工作
- 简化 Provider 切换
- 统一的费用统计
- 社区活跃支持多模型
- 降低学习和维护成本

---

### 73. MessageBus 相比直接调用有什么优势？

**答案**：
- 解耦组件依赖
- 支持动态添加订阅者
- 便于扩展新功能
- 事件可追溯和调试
- 支持异步处理

---

## 故障排除篇

### 74. Channel 连接失败怎么办？

**答案**：
- 检查网络连接
- 验证认证凭证
- 查看错误日志
- 确认平台服务正常
- 尝试重新启动网关

---

### 75. LLM 返回空响应如何处理？

**答案**：
- 检查 Prompt 是否合适
- 减少上下文长度
- 调整生成参数
- 确认模型可用
- 尝试其他模型

---

### 76. 工具调用失败怎么办？

**答案**：
- 检查工具配置正确性
- 验证依赖服务可用
- 查看错误信息
- 调整 Tool 参数
- 确认权限设置

---

### 77. 对话丢失或状态异常怎么办？

**答案**：
- 检查 Session 配置
- 查看持久化状态
- 重新启动对话
- 清理临时文件
- 调整 Session 超时

---

## 性能篇

### 78. 如何优化 Nanobot 的响应速度？

**答案**：
- 选择低延迟的 LLM
- 减少上下文长度
- 优化工具执行效率
- 使用缓存机制
- 监控性能瓶颈

---

### 79. 如何减少 LLM 调用成本？

**答案**：
- 使用更便宜的模型
- 压缩上下文内容
- 减少不必要的迭代
- 设置 max_tokens 限制
- 分析使用模式

---

### 80. Nanobot 能处理高并发吗？

**答案**：
- 异步架构支持并发
- 每个 Channel 独立处理
- 可以水平扩展部署
- 受限于单实例资源
- 考虑分布式架构

---

## 架构细节篇

### 81. 解释 Nanobot 中的 Event 类结构。

**答案**：
- Event 是所有事件类型的基类
- 包含事件类型、数据、时间戳
- 支持序列化传输
- 可以携带元信息
- 订阅者根据类型处理

---

### 82. AgentLoop 中的 `_register_default_tools()` 做了什么？

**答案**：
- 注册所有内置工具
- 添加工具到代理实例
- 配置工具的默认行为
- 返回工具列表
- 允许运行时动态添加

---

### 83. Provider 接口如何支持多模型？

**答案**：
- LiteLLM 统一模型格式
- 动态路由到不同端点
- 配置中指定模型名称
- 运行时切换模型
- 支持模型别名

---

### 84. Channel 适配器如何处理平台差异？

**答案**：
- 封装平台特定协议
- 转换消息为统一格式
- 处理认证和会话
- 实现统一的发送接口
- 独立处理连接和重连

---

### 85. Workspace 文件的加载时机和方式？

**答案**：
- 代理启动时加载
- 读取 `~/.nanobot/workspace/` 目录
- 解析 Markdown 内容
- 传递给 LLM 作为上下文
- 支持热重载配置

---

## 综合篇

### 86. 设计一个自定义 Tool 的完整流程。

**答案**：
1. 继承 `Tool` 基类
2. 实现 `name`、`description` 属性
3. 实现 `execute()` 方法
4. 在 AgentLoop 中注册
5. 测试工具功能
6. 文档化用法

---

### 87. 如何将 Nanobot 部署到生产环境？

**答案**：
- 使用进程管理（如 systemd）
- 配置日志轮转
- 设置资源限制
- 监控健康状态
- 配置备份策略
- 使用反向代理

---

### 88. 解释 Nanobot 的设计哲学。

**答案**：
- 极简主义：少量代码，易于理解
- 可扩展性：模块化设计
- 隐私优先：本地运行
- 用户控制：透明可定制
- 轻量级：最低依赖

---

### 89. Nanobot 的长期记忆机制如何设计？

**答案**：
- 使用 Markdown 文件存储
- 代理可以读写 memory/MEMORY.md
- 支持摘要和检索
- 跨会话持久化
- 定期清理和维护

---

### 90. 如何实现多代理协作？

**答案**：
- 使用 Subagent 嵌套调用
- 通过 MessageBus 传递消息
- 定义代理间的协议
- 共享 Workspace 配置
- 使用 Skill 模板化

---

## 高难度篇

### 91. Nanobus 的事件流控机制是如何实现的？

**答案**：
- 使用缓冲区存储待处理事件
- 支持背压（backpressure）策略
- 可以配置队列大小
- 超时和丢弃策略
- 保证系统稳定性

---

### 92. 解释 AgentLoop 中的上下文窗口管理。

**答案**：
- 跟踪当前 token 使用
- 动态调整上下文内容
- 支持多种压缩策略
- 优先保留关键信息
- 防止超出模型限制

---

### 93. 如何实现 Tool 的超时和取消？

**答案**：
- 使用 asyncio.wait_for() 超时
- 支持取消 Token 传递
- 捕获超时异常处理
- 设置合理的超时时间
- 清理资源避免泄漏

---

### 94. Nanobot 的分布式部署方案是怎样的？

**答案**：
- 消息总线可使用 Redis
- Channel 和 Agent 可分离
- 水平扩展 Agent 实例
- 使用负载均衡
- 保证消息顺序和一致性

---

### 95. 解释 Tool 执行结果的归一化处理。

**答案**：
- 统一 Tool 返回格式
- 转换为 LLM 可理解的消息
- 处理错误和异常情况
- 提取结构化数据
- 合并到对话上下文

---

## 经验篇

### 96. 有效使用 Nanobot 的最佳实践有哪些？

**答案**：
- 精心设计 AGENTS.md 和 SOUL.md
- 合理设置对话长度限制
- 为不同场景创建不同 Skills
- 定期维护 MEMORY.md
- 监控和优化成本

---

### 97. 遇到复杂任务时如何分解？

**答案**：
- 识别任务边界
- 创建专门的 Subagent
- 使用工具辅助处理
- 逐步验证中间结果
- 合并最终输出

---

### 98. 如何调试 LLM 的"幻觉"问题？

**答案**：
- 在 Prompt 中要求引用来源
- 限制回答范围
- 验证工具调用的准确性
- 后处理检查关键事实
- 调整模型或参数

---

### 99. 设计高效 System Prompt 的技巧。

**答案**：
- 明确角色和约束
- 提供示例（few-shot）
- 结构化指令内容
- 迭代测试和优化
- 注意长度和清晰度

---

### 100. Nanobot 项目有什么局限性和改进空间？

**答案**：
**局限性**：
- 单用户设计，多用户支持有限
- 纯文本交互，多媒体支持少
- 社区规模较小

**改进空间**：
- 插件系统
- Web UI 管理界面
- 更多的 Channel 支持
- 多代理协作框架
- 更好的可视化调试
